<!DOCTYPE html><html><head>
        <script src="../../three.min.js"></script>
        <script id="vertex1" type="x-shader/x-vertex">//<![CDATA[
// Cette variable sera passée (après interpolation) à chaque pixel
// traité par le fragment-shader. C'est un vecteurs dont les coordonnées
// sont comprises entre -1.0 et +1.0.
varying vec2 var_XY;

// Fonction principage du shader, appelée pour chaque vertex.
void main(void) {
  // `position` est un vec3 global qui contient les coordonnées
  // du vertex courant.
  float x = position.x;
  float y = position.y;

  // On se ramève à un carré centré en (0,0) et de côté 2.
  if (x > 0.0) {
    if (y > 0.0) {
      var_XY = vec2( 1.0, 1.0 );
    } else {
      var_XY = vec2( 1.0, -1.0 );
    }
  } else {
    if (y > 0.0) {
      var_XY = vec2( -1.0, 1.0 );
    } else {
      var_XY = vec2( -1.0, -1.0 );
    }
  }

  // `gl_Position` : coordonnées du vertex dans le repère de l'écran.
  // `position` : coordonnées du vertex dans le repère de son modèle.
  // `modelViewMatrix` : passage du repère du modèle dans le repère
  //                     de la caméra.
  // `projectionMatrix` : passage du repère de la caméra dans celui
  //                      de l'écran.
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}//]]></script>
        <script id="fragment1" type="x-shader/x-fragment">//<![CDATA[
// Variable récupérée (après interpolation) du vertex-shader.
varying vec2 var_XY;

// Fonction appelée pour chaque pixel visible de l'écran.
void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;

  // La distance du point (x,y) au centre de l'écran (0,0)
  // permet de savoir si on est dans le cercle ou dehors.
  float r = x*x + y*y;
  if (r < 1.0) {
    // Si on est dans le cercle, on met un pixel rouge.
    // 
    gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
  } else {
    // Si on est hors du cercle, on met un pixel transparent.
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 1.0 );
  }    
}//]]></script>
        <script id="vertex2" type="x-shader/x-vertex">//<![CDATA[
// Cette variable sera passée (après interpolation) à chaque pixel
// traité par le fragment-shader. C'est un vecteurs dont les coordonnées
// sont comprises entre -1.0 et +1.0.
varying vec2 var_XY;

void main(void) {
  float x = position.x;
  float y = position.y;

  if (x > 0.0) {
    if (y > 0.0) {
      var_XY = vec2( 1.0, 1.0 );
    } else {
      var_XY = vec2( 1.0, -1.0 );
    }
  } else {
    if (y > 0.0) {
      var_XY = vec2( -1.0, 1.0 );
    } else {
      var_XY = vec2( -1.0, -1.0 );
    }
  }

  // Pour que le carré nous fasse toujours face, il faut
  // commencer par projeter son centre dans le repère
  // de l'écran.
  vec4 center = vec4( 0.0, 0.0, position.z, 1.0 );
  vec4 p = projectionMatrix * modelViewMatrix * center;
  // Cela nous donne la valeur du `z` et on peut reconstituer
  // le `x` et le `y` en utilisant les coordonnées dans le
  // repère du modèle.
  p.x += var_XY.x * 0.5;
  p.y += var_XY.y * 0.5;
  
  gl_Position = p;
}//]]></script>
        <script id="fragment2" type="x-shader/x-fragment">//<![CDATA[
// Variable récupérée (après interpolation) du vertex-shader.
varying vec2 var_XY;

// Couleur de la boule.
uniform vec3 uni_Color;

// Fonction appelée pour chaque pixel visible de l'écran.
void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;

  // La distance du point (x,y) au centre de l'écran (0,0)
  // permet de savoir si on est dans le cercle ou dehors.
  float r = x*x + y*y;
  if (r < 1.0) {
    // Si on est dans le cercle, on met un pixel `uni_Color`.
    gl_FragColor = vec4( uni_Color, 1.0 );
  } else {
    // Si on est hors du cercle, on met un pixel transparent.
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 0.0 );
  }    
}//]]></script>
        <script id="fragment3" type="x-shader/x-fragment">//<![CDATA[
// Variable récupérée (après interpolation) du vertex-shader.
varying vec2 var_XY;

// Couleur de la boule.
uniform vec3 uni_Color;

// Fonction appelée pour chaque pixel visible de l'écran.
void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;

  // La distance du point (x,y) au centre de l'écran (0,0)
  // permet de savoir si on est dans le cercle ou dehors.
  float r = x*x + y*y;
  if (r < 1.0) {
    // Si on est dans le cercle, on met un pixel `uni_Color`.
    gl_FragColor = vec4( (1.0 - 0.75 * r) * uni_Color, 1.0 );
  } else {
    // Si on est hors du cercle, on met un pixel transparent.
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 0.0 );
  }    
}//]]></script>
        <script id="fragment4" type="x-shader/x-fragment">//<![CDATA[
varying vec2 var_XY;
uniform vec3 uni_Color;

// Couleur du point qui fait face à la lumière.
const vec3 cst_LightColorFront = vec3( 1.0, 1.0, 1.0 );
// Couleur du point qui tourne le dos à la lumière.
const vec3 cst_LightColorBack = vec3( 0.0, 0.0, 0.0 );

void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;
  float r = x*x + y*y;

  if (r < 1.0) {
    // Le vecteur normal au point (x,y) a pour coordonnées (x,y,z).
    float z = sqrt( 1.0 - r );
    // Direction de la lumière.
    // Je prends une direction au hasard et constante pour
    // le moment.
    vec3 dir = normalize( vec3( 7, 2, 5) );
    // Produit scalaire qui est maximal quand le vecteur normal
    // est parallèle et dans le même sens que le vecteur `dir`.
    float a = dot( dir, vec3( x, y, z ) );

    if (a > 0.0) {
      // On interpole suivant `a` entre 
      // la couleur de la sphère et celle de la lumière.
      gl_FragColor = vec4( a * cst_LightColorFront + (1.0 - a) * uni_Color, 1.0);
    } else {
      // La même chose pour la partie à l'ombre.
      a = -a;
      gl_FragColor = vec4( a * cst_LightColorBack + (1.0 - a) * uni_Color, 1.0);
    }
  } else {
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 0.0 );
  }
}//]]></script>
        <script id="fragment5" type="x-shader/x-fragment">//<![CDATA[
varying vec2 var_XY;
uniform vec3 uni_Color;

// Les `Value` permettent de minimiser l'éclat de la lumière.
const float cst_LightValueFront = 0.7;
const float cst_LightValueBack = 1.0;
const vec3 cst_LightColorFront = vec3( 0.9, 0.9, 0.8 );
const vec3 cst_LightColorBack = vec3( 0.0, 0.0, 0.2 );

void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;
  float r = x*x + y*y;

  if (r < 1.0) {
    // Pour limiter l'éclat de la lumière, on modifie sa couleur
    // en la moyennant avec la couleur de la sphère.
    vec3 colorFront = cst_LightColorFront * cst_LightValueFront
      + uni_Color * (1.0 - cst_LightValueFront);
    vec3 colorBack = cst_LightColorBack * cst_LightValueBack
      + uni_Color * (1.0 - cst_LightValueBack);

    float z = sqrt( 1.0 - r );
    vec3 dir = normalize( vec3( 7, 2, 5) );
    float a = dot( dir, vec3( x, y, z ) );

    if (a > 0.0) {
      gl_FragColor = vec4( a * colorFront + (1.0 - a) * uni_Color, 1.0);
    } else {
      a = -a;
      gl_FragColor = vec4( a * colorBack + (1.0 - a) * uni_Color, 1.0);
    }
  } else {
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 0.0 );
  }
}//]]></script>
        <script id="vertex3" type="x-shader/x-vertex">//<![CDATA[
varying vec2 var_XY;
varying vec3 var_Position;

void main(void) {
  float x = position.x;
  float y = position.y;

  if (x > 0.0) {
    if (y > 0.0) {
      var_XY = vec2( 1.0, 1.0 );
    } else {
      var_XY = vec2( 1.0, -1.0 );
    }
  } else {
    if (y > 0.0) {
      var_XY = vec2( -1.0, 1.0 );
    } else {
      var_XY = vec2( -1.0, -1.0 );
    }
  }

  vec4 center = vec4( 0.0, 0.0, position.z, 1.0 );
  vec4 p = projectionMatrix * modelViewMatrix * center;
  p.x += var_XY.x * 0.5;
  p.y += var_XY.y * 0.5;
  
  gl_Position = p;
  var_Position = vec3(gl_Position);
}//]]></script>
        <script id="fragment6" type="x-shader/x-fragment">//<![CDATA[
varying vec2 var_XY;
varying vec3 var_Position;

uniform vec3 uni_Color;

const float cst_LightValueFront = 0.7;
const float cst_LightValueBack = 1.0;
const vec3 cst_LightColorFront = vec3( 0.9, 0.9, 0.8 );
const vec3 cst_LightColorBack = vec3( 0.0, 0.0, 0.2 );

void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;
  float r = x*x + y*y;

  // On a inversé la condition pour faire tout de
  // suite un sort aux pixels invisibles.
  if (r >= 1.0) {
    gl_FragColor = vec4( 0.0, 0.0, 0.0, 0.0 );
    return;
  }

  if (r > 0.8) {
    // Le liseré noir autour de la sphère est créé ainsi.
    // En diminuant 0.99, on épaissit le trait.
    gl_FragColor = vec4( uni_Color * 0.3, 1.0 );
  } 
  else {
    vec3 color = vec3(uni_Color);

    vec3 colorFront = cst_LightColorFront * cst_LightValueFront
      + uni_Color * (1.0 - cst_LightValueFront);
    vec3 colorBack = cst_LightColorBack * cst_LightValueBack
      + uni_Color * (1.0 - cst_LightValueBack);

    float z = sqrt( 1.0 - r );
    vec3 dir = normalize( vec3( 7, 2, 5) - cameraPosition );
    float a = dot( dir, vec3( x, y, z ) );

    if (a > 0.0) {
      color = a * colorFront + (1.0 - a) * uni_Color;
    } else {
      a = -a;
      color = a * colorBack + (1.0 - a) * uni_Color;
    }

    color *= 1.0 - r * 0.6;
    gl_FragColor = vec4( color, 1.0 );
  }
}//]]></script>
    <title>La piscine à boules</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Articles concernant majoritairement l'algorithmie"></meta><script defer="null" src="../../js/articles/piscine_a_boule/@piscine_a_boule.1.js"></script><link rel="stylesheet" type="text/css" href="../../css/articles/piscine_a_boule/@piscine_a_boule.1.css"></head><body><section class="x-article custom"><header><a class="back" href="../../index.html">◀</a>La piscine à boules</header><article><p><a name="page2"></a></p>
<p>Je donne donc une rotation à chaque carré pour qu&#39;il s&#39;oriente vers la caméra.
<center>
<div id="piscine.bouncing-squares.face-me4" style="display:none"></div>
</center></p>
<p>J&#39;en ai profité pour rentrer à l&#39;intérieur de la piscine et mieux observer les détails de près.
Il ne me reste plus qu&#39;à dessiner de jolis sphères sur ces carrés et je pourrai mystifier le Thom&#39;.
Mais attention, il a l&#39;oeil le bougre ! Alors pas question de plaquer une texture avec un photo de sphère : les images pixelisent quand on les regarde de trop près. Non, il va falloir y aller à grands coups de <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context#The_shaders">shaders</a>.</p>
<p>En gros, les shaders permettent de déterminer la couleur d&#39;un pixel à l&#39;écran. Les jolis effets de lumière sur les faces d&#39;un chouette polyèdre, c&#39;est grâce aux shaders. Il en existe des tonnes que l&#39;on peut utiliser sans savoir comment ça fonctionne, mais dans notre cas, il va falloir plonger dans la théorie.</p>
<p>Il existe deux types de shaders :</p>
<ul>
<li><strong>vertex shader</strong> : associe tout un tas d&#39;attributs à un sommet (vertex en anglais), et convertit les coordonnées dans le référentiel de la caméra.</li>
<li><strong>fragment_shader</strong> : associe une couleur à un pixel donné déterminé par les attributs des sommets environnants.</li>
</ul>
<p>Ensuite, le maître mot est <a href="https://fr.wikipedia.org/wiki/Interpolation_lin%C3%A9aire"><strong>interpolation</strong></a>.</p>
<p>Supposons que le <em>vertex-shader</em> associe un couleur différente à chaque sommet d&#39;un triangle.
Alors, quand le <em>fragment-shader</em> devra déterminer la couleur d&#39;un pixel au beau milieu de ce triangle, il recevra comme attribut de couleur une interpolation des couleurs des trois sommets.</p>
<p>Voici le code du <em>vertex-shader</em> :
<pre class="custom highlight js">
    <span class="comment">// Cette variable sera passée (après interpolation) à chaque pixel
    </span><span class="comment">// traité par le fragment-shader. C'est un vecteurs dont les coordonnées
    </span><span class="comment">// sont comprises entre -1.0 et +1.0.
    </span>varying vec2 var_XY;
    
    <span class="comment">// Fonction principage du shader, appelée pour chaque vertex.
    </span>void <span class="function">main</span><span class="keyword">(void</span>) {
      <span class="comment">// `position` est un vec3 global qui contient les coordonnées
    </span>  <span class="comment">// du vertex courant.
    </span>  float x <span class="operator">=</span> position.x;
      float y <span class="operator">=</span> position.y;
    
      <span class="comment">// On se ramève à un carré centré en (0,0) et de côté 2.
    </span> <span class="keyword"> if</span> (x <span class="operator">&gt;</span> 0.0) {
       <span class="keyword"> if</span> (y <span class="operator">&gt;</span> 0.0) {
          var_XY <span class="operator">=</span> <span class="function">vec2</span>( 1.0, 1.0 );
        }<span class="keyword"> else</span> {
          var_XY <span class="operator">=</span> <span class="function">vec2</span>( 1.0, <span class="operator">-</span>1.0 );
        }
      }<span class="keyword"> else</span> {
       <span class="keyword"> if</span> (y <span class="operator">&gt;</span> 0.0) {
          var_XY <span class="operator">=</span> <span class="function">vec2</span>( <span class="operator">-</span>1.0, 1.0 );
        }<span class="keyword"> else</span> {
          var_XY <span class="operator">=</span> <span class="function">vec2</span>( <span class="operator">-</span>1.0, <span class="operator">-</span>1.0 );
        }
      }
    
      <span class="comment">// `gl_Position` : coordonnées du vertex dans le repère de l'écran.
    </span>  <span class="comment">// `position` : coordonnées du vertex dans le repère de son modèle.
    </span>  <span class="comment">// `modelViewMatrix` : passage du repère du modèle dans le repère
    </span>  <span class="comment">//                     de la caméra.
    </span>  <span class="comment">// `projectionMatrix` : passage du repère de la caméra dans celui
    </span>  <span class="comment">//                      de l'écran.
    </span>  gl_Position <span class="operator">=</span> projectionMatrix <span class="operator">*</span> modelViewMatrix <span class="operator">*</span> <span class="function">vec4</span>( position, 1.0 );
    }</pre></p>
<p>Et voici celui du <em>fragment-shader</em> :
<pre class="custom highlight js">
    <span class="comment">// Variable récupérée (après interpolation) du vertex-shader.
    </span>varying vec2 var_XY;
    
    <span class="comment">// Fonction appelée pour chaque pixel visible de l'écran.
    </span>void <span class="function">main</span><span class="keyword">(void</span>) {
      float x <span class="operator">=</span> var_XY.x;
      float y <span class="operator">=</span> var_XY.y;
    
      <span class="comment">// La distance du point (x,y) au centre de l'écran (0,0)
    </span>  <span class="comment">// permet de savoir si on est dans le cercle ou dehors.
    </span>  float r <span class="operator">=</span> x<span class="operator">*</span>x <span class="operator">+</span> y<span class="operator">*</span>y;
     <span class="keyword"> if</span> (r <span class="operator">&lt;</span> 1.0) {
        <span class="comment">// Si on est dans le cercle, on met un pixel rouge.
    </span>    <span class="comment">// 
    </span>    gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( 1.0, 0.0, 0.0, 1.0 );
      }<span class="keyword"> else</span> {
        <span class="comment">// Si on est hors du cercle, on met un pixel transparent.
    </span>    gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( 0.0, 1.0, 0.0, 1.0 );
      }    
    }</pre></p>
<p>Avec ces deux, je crée un <em>Material</em> comme ceci (avec <code>three.js</code>) :
<pre class="custom highlight js">
    new THREE.<span class="function">ShaderMaterial</span>({
        vertexShader: document.<span class="function">getElementById</span>( 'vertex1' ).textContent,
        fragmentShader: document.<span class="function">getElementById</span>( 'fragment1' ).textContent,
        transparent: true
    })</pre></p>
<p><center>
<div id="piscine.shader5" style="display:none"></div>
<div id="piscine.shader26" style="display:none"></div>
</center></p>
<p>En y regardant de plus près, je m&#39;apreçois que la technique de faire tourner les carrés pour qu&#39;ils me fassent face n&#39;est pas très bonne. En effet, par moment, ils ont tendance à tourner un peu autour de l&#39;axe Z. Ce que je veux, moi, c&#39;est que leurs côtés soient toujours parallèles aux bords de l&#39;écran.</p>
<p>Je dois pouvoir utiliser le <em>vertex-shader</em> pour cela, mais oui !</p>
<p><pre class="custom highlight js">
    <span class="comment">// Cette variable sera passée (après interpolation) à chaque pixel
    </span><span class="comment">// traité par le fragment-shader. C'est un vecteurs dont les coordonnées
    </span><span class="comment">// sont comprises entre -1.0 et +1.0.
    </span>varying vec2 var_XY;
    <span class="keyword">
    void</span> <span class="function">main</span><span class="keyword">(void</span>) {
      float x <span class="operator">=</span> position.x;
      float y <span class="operator">=</span> position.y;
    
     <span class="keyword"> if</span> (x <span class="operator">&gt;</span> 0.0) {
       <span class="keyword"> if</span> (y <span class="operator">&gt;</span> 0.0) {
          var_XY <span class="operator">=</span> <span class="function">vec2</span>( 1.0, 1.0 );
        }<span class="keyword"> else</span> {
          var_XY <span class="operator">=</span> <span class="function">vec2</span>( 1.0, <span class="operator">-</span>1.0 );
        }
      }<span class="keyword"> else</span> {
       <span class="keyword"> if</span> (y <span class="operator">&gt;</span> 0.0) {
          var_XY <span class="operator">=</span> <span class="function">vec2</span>( <span class="operator">-</span>1.0, 1.0 );
        }<span class="keyword"> else</span> {
          var_XY <span class="operator">=</span> <span class="function">vec2</span>( <span class="operator">-</span>1.0, <span class="operator">-</span>1.0 );
        }
      }
    
      <span class="comment">// Pour que le carré nous fasse toujours face, il faut
    </span>  <span class="comment">// commencer par projeter son centre dans le repère
    </span>  <span class="comment">// de l'écran.
    </span>  vec4 center <span class="operator">=</span> <span class="function">vec4</span>( 0.0, 0.0, position.z, 1.0 );
      vec4 p <span class="operator">=</span> projectionMatrix <span class="operator">*</span> modelViewMatrix <span class="operator">*</span> center;
      <span class="comment">// Cela nous donne la valeur du `z` et on peut reconstituer
    </span>  <span class="comment">// le `x` et le `y` en utilisant les coordonnées dans le
    </span>  <span class="comment">// repère du modèle.
    </span>  p.x <span class="operator">+</span><span class="operator">=</span> var_XY.x <span class="operator">*</span> 0.5;
      p.y <span class="operator">+</span><span class="operator">=</span> var_XY.y <span class="operator">*</span> 0.5;
      
      gl_Position <span class="operator">=</span> p;
    }</pre></p>
<p><hr/></p>
<p>Ok, mais j&#39;aimerais maintenant avoir des boules de différentes couleurs et sans le fond vert.
Voyons cela sur la <a href="piscine_a_boule.2.html#page3">page suivante</a>.</p>
<div style="height:1rem"></div><footer>Pages : <span><a href="piscine_a_boule.html">1</a></span><span><span class="selected">2</span></span><span><a href="piscine_a_boule.2.html">3</a></span><span><a href="piscine_a_boule.3.html">4</a></span><span><a href="piscine_a_boule.4.html">5</a></span><span><a href="piscine_a_boule.5.html">6</a></span></footer></article></section></body></html>