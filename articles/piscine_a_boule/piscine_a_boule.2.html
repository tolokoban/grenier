<!DOCTYPE html><html><head>
        <script src="../../three.min.js"></script>
        <script id="vertex1" type="x-shader/x-vertex">//<![CDATA[
// Cette variable sera passée (après interpolation) à chaque pixel
// traité par le fragment-shader. C'est un vecteurs dont les coordonnées
// sont comprises entre -1.0 et +1.0.
varying vec2 var_XY;

// Fonction principage du shader, appelée pour chaque vertex.
void main(void) {
  // `position` est un vec3 global qui contient les coordonnées
  // du vertex courant.
  float x = position.x;
  float y = position.y;

  // On se ramève à un carré centré en (0,0) et de côté 2.
  if (x > 0.0) {
    if (y > 0.0) {
      var_XY = vec2( 1.0, 1.0 );
    } else {
      var_XY = vec2( 1.0, -1.0 );
    }
  } else {
    if (y > 0.0) {
      var_XY = vec2( -1.0, 1.0 );
    } else {
      var_XY = vec2( -1.0, -1.0 );
    }
  }

  // `gl_Position` : coordonnées du vertex dans le repère de l'écran.
  // `position` : coordonnées du vertex dans le repère de son modèle.
  // `modelViewMatrix` : passage du repère du modèle dans le repère
  //                     de la caméra.
  // `projectionMatrix` : passage du repère de la caméra dans celui
  //                      de l'écran.
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}//]]></script>
        <script id="fragment1" type="x-shader/x-fragment">//<![CDATA[
// Variable récupérée (après interpolation) du vertex-shader.
varying vec2 var_XY;

// Fonction appelée pour chaque pixel visible de l'écran.
void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;

  // La distance du point (x,y) au centre de l'écran (0,0)
  // permet de savoir si on est dans le cercle ou dehors.
  float r = x*x + y*y;
  if (r < 1.0) {
    // Si on est dans le cercle, on met un pixel rouge.
    // 
    gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
  } else {
    // Si on est hors du cercle, on met un pixel transparent.
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 1.0 );
  }    
}//]]></script>
        <script id="vertex2" type="x-shader/x-vertex">//<![CDATA[
// Cette variable sera passée (après interpolation) à chaque pixel
// traité par le fragment-shader. C'est un vecteurs dont les coordonnées
// sont comprises entre -1.0 et +1.0.
varying vec2 var_XY;

void main(void) {
  float x = position.x;
  float y = position.y;

  if (x > 0.0) {
    if (y > 0.0) {
      var_XY = vec2( 1.0, 1.0 );
    } else {
      var_XY = vec2( 1.0, -1.0 );
    }
  } else {
    if (y > 0.0) {
      var_XY = vec2( -1.0, 1.0 );
    } else {
      var_XY = vec2( -1.0, -1.0 );
    }
  }

  // Pour que le carré nous fasse toujours face, il faut
  // commencer par projeter son centre dans le repère
  // de l'écran.
  vec4 center = vec4( 0.0, 0.0, position.z, 1.0 );
  vec4 p = projectionMatrix * modelViewMatrix * center;
  // Cela nous donne la valeur du `z` et on peut reconstituer
  // le `x` et le `y` en utilisant les coordonnées dans le
  // repère du modèle.
  p.x += var_XY.x * 0.5;
  p.y += var_XY.y * 0.5;
  
  gl_Position = p;
}//]]></script>
        <script id="fragment2" type="x-shader/x-fragment">//<![CDATA[
// Variable récupérée (après interpolation) du vertex-shader.
varying vec2 var_XY;

// Couleur de la boule.
uniform vec3 uni_Color;

// Fonction appelée pour chaque pixel visible de l'écran.
void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;

  // La distance du point (x,y) au centre de l'écran (0,0)
  // permet de savoir si on est dans le cercle ou dehors.
  float r = x*x + y*y;
  if (r < 1.0) {
    // Si on est dans le cercle, on met un pixel `uni_Color`.
    gl_FragColor = vec4( uni_Color, 1.0 );
  } else {
    // Si on est hors du cercle, on met un pixel transparent.
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 0.0 );
  }    
}//]]></script>
        <script id="fragment3" type="x-shader/x-fragment">//<![CDATA[
// Variable récupérée (après interpolation) du vertex-shader.
varying vec2 var_XY;

// Couleur de la boule.
uniform vec3 uni_Color;

// Fonction appelée pour chaque pixel visible de l'écran.
void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;

  // La distance du point (x,y) au centre de l'écran (0,0)
  // permet de savoir si on est dans le cercle ou dehors.
  float r = x*x + y*y;
  if (r < 1.0) {
    // Si on est dans le cercle, on met un pixel `uni_Color`.
    gl_FragColor = vec4( (1.0 - 0.75 * r) * uni_Color, 1.0 );
  } else {
    // Si on est hors du cercle, on met un pixel transparent.
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 0.0 );
  }    
}//]]></script>
        <script id="fragment4" type="x-shader/x-fragment">//<![CDATA[
varying vec2 var_XY;
uniform vec3 uni_Color;

// Couleur du point qui fait face à la lumière.
const vec3 cst_LightColorFront = vec3( 1.0, 1.0, 1.0 );
// Couleur du point qui tourne le dos à la lumière.
const vec3 cst_LightColorBack = vec3( 0.0, 0.0, 0.0 );

void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;
  float r = x*x + y*y;

  if (r < 1.0) {
    // Le vecteur normal au point (x,y) a pour coordonnées (x,y,z).
    float z = sqrt( 1.0 - r );
    // Direction de la lumière.
    // Je prends une direction au hasard et constante pour
    // le moment.
    vec3 dir = normalize( vec3( 7, 2, 5) );
    // Produit scalaire qui est maximal quand le vecteur normal
    // est parallèle et dans le même sens que le vecteur `dir`.
    float a = dot( dir, vec3( x, y, z ) );

    if (a > 0.0) {
      // On interpole suivant `a` entre 
      // la couleur de la sphère et celle de la lumière.
      gl_FragColor = vec4( a * cst_LightColorFront + (1.0 - a) * uni_Color, 1.0);
    } else {
      // La même chose pour la partie à l'ombre.
      a = -a;
      gl_FragColor = vec4( a * cst_LightColorBack + (1.0 - a) * uni_Color, 1.0);
    }
  } else {
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 0.0 );
  }
}//]]></script>
        <script id="fragment5" type="x-shader/x-fragment">//<![CDATA[
varying vec2 var_XY;
uniform vec3 uni_Color;

// Les `Value` permettent de minimiser l'éclat de la lumière.
const float cst_LightValueFront = 0.7;
const float cst_LightValueBack = 1.0;
const vec3 cst_LightColorFront = vec3( 0.9, 0.9, 0.8 );
const vec3 cst_LightColorBack = vec3( 0.0, 0.0, 0.2 );

void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;
  float r = x*x + y*y;

  if (r < 1.0) {
    // Pour limiter l'éclat de la lumière, on modifie sa couleur
    // en la moyennant avec la couleur de la sphère.
    vec3 colorFront = cst_LightColorFront * cst_LightValueFront
      + uni_Color * (1.0 - cst_LightValueFront);
    vec3 colorBack = cst_LightColorBack * cst_LightValueBack
      + uni_Color * (1.0 - cst_LightValueBack);

    float z = sqrt( 1.0 - r );
    vec3 dir = normalize( vec3( 7, 2, 5) );
    float a = dot( dir, vec3( x, y, z ) );

    if (a > 0.0) {
      gl_FragColor = vec4( a * colorFront + (1.0 - a) * uni_Color, 1.0);
    } else {
      a = -a;
      gl_FragColor = vec4( a * colorBack + (1.0 - a) * uni_Color, 1.0);
    }
  } else {
    gl_FragColor = vec4( 0.0, 1.0, 0.0, 0.0 );
  }
}//]]></script>
        <script id="vertex3" type="x-shader/x-vertex">//<![CDATA[
varying vec2 var_XY;
varying vec3 var_Position;

void main(void) {
  float x = position.x;
  float y = position.y;

  if (x > 0.0) {
    if (y > 0.0) {
      var_XY = vec2( 1.0, 1.0 );
    } else {
      var_XY = vec2( 1.0, -1.0 );
    }
  } else {
    if (y > 0.0) {
      var_XY = vec2( -1.0, 1.0 );
    } else {
      var_XY = vec2( -1.0, -1.0 );
    }
  }

  vec4 center = vec4( 0.0, 0.0, position.z, 1.0 );
  vec4 p = projectionMatrix * modelViewMatrix * center;
  p.x += var_XY.x * 0.5;
  p.y += var_XY.y * 0.5;
  
  gl_Position = p;
  var_Position = vec3(gl_Position);
}//]]></script>
        <script id="fragment6" type="x-shader/x-fragment">//<![CDATA[
varying vec2 var_XY;
varying vec3 var_Position;

uniform vec3 uni_Color;

const float cst_LightValueFront = 0.7;
const float cst_LightValueBack = 1.0;
const vec3 cst_LightColorFront = vec3( 0.9, 0.9, 0.8 );
const vec3 cst_LightColorBack = vec3( 0.0, 0.0, 0.2 );

void main(void) {
  float x = var_XY.x;
  float y = var_XY.y;
  float r = x*x + y*y;

  // On a inversé la condition pour faire tout de
  // suite un sort aux pixels invisibles.
  if (r >= 1.0) {
    gl_FragColor = vec4( 0.0, 0.0, 0.0, 0.0 );
    return;
  }

  if (r > 0.8) {
    // Le liseré noir autour de la sphère est créé ainsi.
    // En diminuant 0.99, on épaissit le trait.
    gl_FragColor = vec4( uni_Color * 0.3, 1.0 );
  } 
  else {
    vec3 color = vec3(uni_Color);

    vec3 colorFront = cst_LightColorFront * cst_LightValueFront
      + uni_Color * (1.0 - cst_LightValueFront);
    vec3 colorBack = cst_LightColorBack * cst_LightValueBack
      + uni_Color * (1.0 - cst_LightValueBack);

    float z = sqrt( 1.0 - r );
    vec3 dir = normalize( vec3( 7, 2, 5) - cameraPosition );
    float a = dot( dir, vec3( x, y, z ) );

    if (a > 0.0) {
      color = a * colorFront + (1.0 - a) * uni_Color;
    } else {
      a = -a;
      color = a * colorBack + (1.0 - a) * uni_Color;
    }

    color *= 1.0 - r * 0.6;
    gl_FragColor = vec4( color, 1.0 );
  }
}//]]></script>
    <title>La piscine à boules</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Articles concernant majoritairement l'algorithmie"></meta><script defer="null" src="../../js/articles/piscine_a_boule/@piscine_a_boule.2.js"></script><link rel="stylesheet" type="text/css" href="../../css/articles/piscine_a_boule/@piscine_a_boule.2.css"></head><body><section class="x-article custom"><header><a class="back" href="../../index.html">◀</a>La piscine à boules</header><article><p><a name="page3"></a></p>
<p>Rien à changer du côté du <em>vertex-shader</em>, en revanche, il faut passer l&#39;information de couleur au <em>fragment-shader</em> :</p>
<p><pre class="custom highlight js">
    new THREE.<span class="function">ShaderMaterial</span>({
        uniforms: {
            <span class="comment">// Les variables de type `uniform` sont constantes
    </span>        <span class="comment">// pour tous les pixels et vertex.
    </span>        uni_Color: {type: <span class="string">"v3"</span>, value: THREE.<span class="function">Vector3</span>(1,0,0);}
        },
        ...
    })</pre></p>
<p>Il faut donc aussi déclarer cette couleur dans le <em>fragment-shader</em> :
<pre class="custom highlight js">
    <span class="comment">// Variable récupérée (après interpolation) du vertex-shader.
    </span>varying vec2 var_XY;
    
    <span class="comment">// Couleur de la boule.
    </span>uniform vec3 uni_Color;
    
    <span class="comment">// Fonction appelée pour chaque pixel visible de l'écran.
    </span>void <span class="function">main</span><span class="keyword">(void</span>) {
      float x <span class="operator">=</span> var_XY.x;
      float y <span class="operator">=</span> var_XY.y;
    
      <span class="comment">// La distance du point (x,y) au centre de l'écran (0,0)
    </span>  <span class="comment">// permet de savoir si on est dans le cercle ou dehors.
    </span>  float r <span class="operator">=</span> x<span class="operator">*</span>x <span class="operator">+</span> y<span class="operator">*</span>y;
     <span class="keyword"> if</span> (r <span class="operator">&lt;</span> 1.0) {
        <span class="comment">// Si on est dans le cercle, on met un pixel `uni_Color`.
    </span>    gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( uni_Color, 1.0 );
      }<span class="keyword"> else</span> {
        <span class="comment">// Si on est hors du cercle, on met un pixel transparent.
    </span>    gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( 0.0, 1.0, 0.0, 0.0 );
      }    
    }</pre>    </p>
<p>Et voilà le travail !
<center><div id="piscine.shader27" style="display:none"></div></center></p>
<p>Même près de la caméra, les sphères ont des bords qui ressemblent à des cercles et pas à des polygones.
Mais je trouve que c&#39;est un peu plat. Je rajoute donc du relief en assombrissant la couleur au fur et à mesure qu&#39;on s&#39;éloigne du centre du cercle.</p>
<p><pre class="custom highlight js">
    gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( (1.0 <span class="operator">-</span> 0.5 <span class="operator">*</span> r) <span class="operator">*</span> uni_Color, 1.0 );</pre></p>
<p><center><div id="piscine.shader28" style="display:none"></div></center></p>
<p>Hey ! C&#39;est quand même plus chouette, non ?</p>
<p>Tout fier, je montre mes résultats à Thomas sur mon FirefoxOS Phone.</p>
<ul>
<li>Ah ! En voilà de belles sphères. Mais il y a quand même quelque chose qui me choque. On dirait que la lumière vient directement de la caméra. Je m&#39;attendait à voir tourner les ombres en même temps que la caméra, non ?</li>
</ul>
<p>Il a raison ce gounafier !! J&#39;ai choisi la facilité, mais ça ne lui a pas échappé. J&#39;enrage...
Je retourne à l&#39;atelier et je m&#39;y remets dare-dare.</p>
<div style="height:1rem"></div><footer>Pages : <span><a href="piscine_a_boule.html">1</a></span><span><a href="piscine_a_boule.1.html">2</a></span><span><span class="selected">3</span></span><span><a href="piscine_a_boule.3.html">4</a></span><span><a href="piscine_a_boule.4.html">5</a></span><span><a href="piscine_a_boule.5.html">6</a></span></footer></article></section></body></html>